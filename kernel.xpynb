{
  "cells": [
    {
      "metadata": {
        "_uuid": "3cb3f3c5c27def83d011f2de99c8cdb79a1b7b45"
      },
      "cell_type": "markdown",
      "source": "**Predicting FIFA 2018 Winner\n**\n\n **Method**:\n- Use data from Kaggle to model the outcome of certain pairings between teams, given their rank, points, and the weighted point difference with the opponent.\n- Use this model to predict the outcome of the group rounds and then the single-elimination phase\n- Compare results with the countries' talent scores\n\nThe analysis can be split into 2 portions:\n\n* Firstly, we will use logistic regression to predict which countries make it to the single elimination round, and subsequently win the world cup.\n>(Reference to [Dr. James Bond's predictive model](https://www.kaggle.com/agostontorok/soccer-world-cup-2018-winner))\n* Secondly, we will use the talent scores of countries to better support the results of the finals matchup.\n\n**Predicted FIFA 2018 winner : Germany**\n\n***Takeaways:***\n\nOverlaying the output with the matchup predictions, we have 3 key observations:\n1.  The logistic regression model coupled with the talent visualization shows that of the 16 top overall talent countries,   11/16 of countries will make it through to the single elimination rounds. \n> While this is inconclusive, it does give an indication that the talent pool available is probably an important factor to a country's perfomance at FIFA. \n> The format of FIFA ensures that not all 16 of the top talent pool countries will make it through to the elimination stages with ease, there are multiple points of upset even before FIFA begins. For example, Italy was previously ousted due to losing to Sweden in the 2nd round playoff in Nov 2017, despite having one of the best talents.\n2. There are multiple matches with almost 50/50 chance for either side to win, this implies that the model is unable to predict with high confidence of some matchups and will need to be tweaked as the results unfold. **(this is what makes it interesting to watch isn't it)**,\n> In the quarterfinals matchup, Argentina vs Portugal, only 1 team will make it to the finals with the top 2 players by overall ratings (Ronaldo & Messi) leading on each side. Interestingly, the winning chances of Portugal is only by 0.01.\n3. In the Finals matchup between Belgium and Germany, there is a substantially higher overall talent score for Germany (4129) as compared to Belgium(3960), even if Belgium were to maximize it's potential, it will only hit a score of 4085 (which is still below Germany's overall score). Hence, unless there is significant environmental influence, both the predictive model & talent assessment results indicate Germany as the champions of FIFA 2018."
    },
    {
      "metadata": {
        "_uuid": "55d7132bf01a6553a087fd6ce7aad6be3553e4f5"
      },
      "cell_type": "markdown",
      "source": "**Data Used**\n\nI used 4 datasets\n- FIFA rankings from 1993 to 2018 (courtesy of [Tadhg Fitzgerald](https://www.kaggle.com/tadhgfitzgerald) \n> This one I used to get the FIFA ranking and points for the teams, which is a monthly changing rank previously shown as a [decent predictor](http://www.sportingintelligence.com/2014/06/20/upsets-giant-killings-adios-bye-bye-fifa-rankings-still-ahead-in-predicting-results-200601/) of team performance\n- International Soccer matches from 1872 to 2018 (courtesy of [Mart JÃ¼risoo](https://www.kaggle.com/martj42))\n> This I will use to find out how much the difference in point, ranks and the current rank of the team affects the outocme of a match\n- FIFA World Cup 2018 data set (courtesy of [Nuggs](https://www.kaggle.com/ahmedelnaggar))\n> This I will use to get the upcoming matches \n- Complete FIFA 2017 Player dataset (Global) (https://www.kaggle.com/artimous/complete-fifa-2017-player-dataset-global)\n> Aggregating countries top players value & strength\n"
    },
    {
      "metadata": {
        "_uuid": "8f2839f25d086af736a60e9eeb907d3b93b6e0e5",
        "_cell_guid": "b1076dfc-b9ad-4769-8c92-a6c4dae69d19",
        "trusted": true,
        "collapsed": true
      },
      "cell_type": "code",
      "source": "import numpy as np # linear algebra\nimport pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)\nfrom matplotlib import pyplot as plt\n\nrankings = pd.read_csv('../input/fifa-international-soccer-mens-ranking-1993now/fifa_ranking.csv')\nrankings = rankings.loc[:,['rank', 'country_full', 'country_abrv', 'cur_year_avg_weighted', 'rank_date', \n                           'two_year_ago_weighted', 'three_year_ago_weighted']]\nrankings = rankings.replace({\"IR Iran\": \"Iran\"})\nrankings['weighted_points'] =  rankings['cur_year_avg_weighted'] + rankings['two_year_ago_weighted'] + rankings['three_year_ago_weighted']\nrankings['rank_date'] = pd.to_datetime(rankings['rank_date'])\n\nmatches = pd.read_csv('../input/international-football-results-from-1872-to-2017/results.csv')\nmatches =  matches.replace({'Germany DR': 'Germany', 'China': 'China PR'})\nmatches['date'] = pd.to_datetime(matches['date'])\n\nworld_cup = pd.read_csv('../input/fifa-worldcup-2018-dataset/World Cup 2018 Dataset.csv')\nworld_cup = world_cup.loc[:, ['Team', 'Group', 'First match \\nagainst', 'Second match\\n against', 'Third match\\n against']]\nworld_cup = world_cup.dropna(how='all')\nworld_cup = world_cup.replace({\"IRAN\": \"Iran\", \n                               \"Costarica\": \"Costa Rica\", \n                               \"Porugal\": \"Portugal\", \n                               \"Columbia\": \"Colombia\", \n                               \"Korea\" : \"Korea Republic\"})\nworld_cup = world_cup.set_index('Team')",
      "execution_count": 46,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "a34c1cd5a26c1024b0638d2d93fc0c691b290024"
      },
      "cell_type": "markdown",
      "source": "**Feature Extraction**\n\nRank data are combined with the day matches are played:\n\nThen extract some features:\n- Point and rank differences\n- Friendly matches are removed, assumption being friendly is not reflective of final results in fifa, which is competitive in nature."
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "863552790217b049b611165e162ad3182f1692f9",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "# I want to have the ranks for every day \nrankings = rankings.set_index(['rank_date'])\\\n            .groupby(['country_full'], group_keys=False)\\\n            .resample('D').first()\\\n            .fillna(method='ffill')\\\n            .reset_index()\n\n# join the ranks\nmatches = matches.merge(rankings, \n                        left_on=['date', 'home_team'], \n                        right_on=['rank_date', 'country_full'])\nmatches = matches.merge(rankings, \n                        left_on=['date', 'away_team'], \n                        right_on=['rank_date', 'country_full'], \n                        suffixes=('_home', '_away'))",
      "execution_count": 47,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "107fa4816e6db551811abd9fc784c34f1ad63682",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "# feature generation\nmatches['rank_difference'] = matches['rank_home'] - matches['rank_away']\nmatches['point_difference'] = matches['weighted_points_home'] - matches['weighted_points_away']\nmatches['score_difference'] = matches['home_score'] - matches['away_score']\nmatches['is_won'] = matches['score_difference'] > 0 # take draw as lost\nmatches['is_stake'] = matches['tournament'] != 'Friendly'\n\n# I tried earlier rest days but it did not turn to be useful",
      "execution_count": 48,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "f67d4cba7bc60580490e00507a0811803e12a6e6"
      },
      "cell_type": "markdown",
      "source": "**Modelling**\n\nI used a Simple Logistic regression (Accuracy = 68.18%)"
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "78e3186d0e783cf2a4cb1a141a8d0ffe9f2b59ba",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "from sklearn import linear_model\nfrom sklearn import ensemble\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, roc_curve, roc_auc_score\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\n\nX, y = matches.loc[:,['rank_home', 'rank_difference', 'point_difference', 'is_stake']], matches['is_won']\nX_train, X_test, y_train, y_test = train_test_split(\n    X, y, test_size=0.2, random_state=42)\n\nlogreg = linear_model.LogisticRegression(C=1e-5)\nfeatures = PolynomialFeatures(degree=2)\nmodel = Pipeline([\n    ('polynomial_features', features),\n    ('logistic_regression', logreg)\n])\nmodel = model.fit(X_train, y_train)\nscore = model.score(X_test,y_test)\ncm = confusion_matrix(y_test, model.predict(X_test))\n\nimport seaborn as sns\nplt.figure(figsize=(9,9))\nsns.heatmap(cm, annot=True, fmt=\".3f\", linewidths=.5, square = True, cmap = 'Blues_r');\nplt.ylabel('Actual label');\nplt.xlabel('Predicted label');\nall_sample_title = 'Accuracy Score: {0}'.format(score)\nplt.title(all_sample_title, size = 15);\n\n\n",
      "execution_count": 50,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "4df844d3dda19501acb22ca095f100eed9787263"
      },
      "cell_type": "markdown",
      "source": "With an accuracy level of 68.18%, the model is decent especially since soccer is a team sport and has a low score per game as compared to sports such as NBA -- which means it's much harder to have a good prediction of win loss outcome when game point differences are marginal."
    },
    {
      "metadata": {
        "_uuid": "479b97e38320c9eba008210903b17951edc84727"
      },
      "cell_type": "markdown",
      "source": "# World Cup simulation"
    },
    {
      "metadata": {
        "_uuid": "16eae35346f7a015d627801e05d0d408f3091964"
      },
      "cell_type": "markdown",
      "source": "## Group rounds"
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "db455e9096f0a41a0abd512193222f366d42c4c8"
      },
      "cell_type": "code",
      "source": "# let's define a small margin when we safer to predict draw then win\nmargin = 0.05\n\n# let's define the rankings at the time of the World Cup\nworld_cup_rankings = rankings.loc[(rankings['rank_date'] == rankings['rank_date'].max()) & \n                                    rankings['country_full'].isin(world_cup.index.unique())]\nworld_cup_rankings = world_cup_rankings.set_index(['country_full'])",
      "execution_count": 51,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "fd197611ef601dcc41c59f48f37f66bec6d2d669",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "from itertools import combinations\n\nworld_cup['points'] = 0\nworld_cup['total_prob'] = 0\n\nfor group in set(world_cup['Group']):\n    print('___Starting group {}:___'.format(group))\n    for home, away in combinations(world_cup.query('Group == \"{}\"'.format(group)).index, 2):\n        print(\"{} vs. {}: \".format(home, away), end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        # entering the rank_home value using loc to search ranking\n        row['rank_home'] = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        # Computing difference in ranking\n        row['rank_difference'] = row['rank_home'] - opp_rank\n        row['point_difference'] = home_points - opp_points\n        \n        home_win_prob = model.predict_proba(row)[:,1][0]\n        world_cup.loc[home, 'total_prob'] += home_win_prob\n        world_cup.loc[away, 'total_prob'] += 1-home_win_prob\n        \n        \n        points = 0\n        if home_win_prob <= 0.5 - margin:\n            print(\"{} wins with {:.2f}\".format(away, 1-home_win_prob))\n            # Establishing the 'points' column here\n            world_cup.loc[away, 'points'] += 3\n        if home_win_prob > 0.5 - margin:\n            points = 1\n        if home_win_prob >= 0.5 + margin:\n            points = 3\n            world_cup.loc[home, 'points'] += 3\n            print(\"{} wins with {:.2f}\".format(home, home_win_prob))\n        if points == 1:\n            print(\"Draw\")\n            world_cup.loc[home, 'points'] += 1\n            world_cup.loc[away, 'points'] += 1",
      "execution_count": 52,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "b2c787fd8541c281f736a4c6b698839f565ac1b8"
      },
      "cell_type": "markdown",
      "source": "## Single-elimination rounds"
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "2eb8426dfc5e4fdd985e8109179e34dac2e9c976",
        "scrolled": true,
        "collapsed": true
      },
      "cell_type": "code",
      "source": "pairing = [0,3,4,7,8,11,12,15,1,2,5,6,9,10,13,14]\n\nworld_cup = world_cup.sort_values(by=['Group', 'points', 'total_prob'], ascending=False).reset_index()\nnext_round_wc = world_cup.groupby('Group').nth([0, 1]) # select the top 2\nnext_round_wc = next_round_wc.reset_index()\nnext_round_wc = next_round_wc.loc[pairing]\nnext_round_wc = next_round_wc.set_index('Team')\n\nfinals = ['round_of_16', 'quarterfinal', 'semifinal', 'final']\n\nlabels = list()\nodds = list()\n\nfor f in finals:\n    print(\"___Starting of the {}___\".format(f))\n    iterations = int(len(next_round_wc) / 2)\n    winners = []\n\n    for i in range(iterations):\n        home = next_round_wc.index[i*2]\n        away = next_round_wc.index[i*2+1]\n        print(\"{} vs. {}: \".format(home,\n                                   away), \n                                   end='')\n        row = pd.DataFrame(np.array([[np.nan, np.nan, np.nan, True]]), columns=X_test.columns)\n        row['rank_home'] = world_cup_rankings.loc[home, 'rank']\n        home_points = world_cup_rankings.loc[home, 'weighted_points']\n        opp_rank = world_cup_rankings.loc[away, 'rank']\n        opp_points = world_cup_rankings.loc[away, 'weighted_points']\n        row['rank_difference'] = row['rank_home'] - opp_rank\n        row['point_difference'] = home_points - opp_points\n\n        home_win_prob = model.predict_proba(row)[:,1][0]\n        if model.predict_proba(row)[:,1] <= 0.5:\n            print(\"{0} wins with probability {1:.2f}\".format(away, 1-home_win_prob))\n            winners.append(away)\n        else:\n            print(\"{0} wins with probability {1:.2f}\".format(home, home_win_prob))\n            winners.append(home)\n\n        labels.append(\"{}({:.2f}) vs. {}({:.2f})\".format(world_cup_rankings.loc[home, 'country_abrv'], \n                                                        1/home_win_prob, \n                                                        world_cup_rankings.loc[away, 'country_abrv'], \n                                                        1/(1-home_win_prob)))\n        odds.append([home_win_prob, 1-home_win_prob])\n                \n    next_round_wc = next_round_wc.loc[winners]\n    print(\"\\n\")",
      "execution_count": 62,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "a3edeb6eba380b54862857fb188d7098acc06933",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "import seaborn as sns\nimport matplotlib.pyplot as plt\n%matplotlib inline\n\nimport plotly.offline as py\npy.init_notebook_mode(connected=True)\nimport plotly.graph_objs as go\nimport plotly.tools as tls",
      "execution_count": 63,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "0504e691f7abaf22517fc055135f71739595742e",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "df = pd.read_csv('../input/complete-player-info/CompleteDataset.csv')\ndf.head()",
      "execution_count": 64,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "587926ebd3049867409ac1eb287391b012a96c11"
      },
      "cell_type": "markdown",
      "source": "**I will assume that the top 50 talents from each country rated by 'Overall' score is representative of the country's soccer capabilities**"
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "519f398a3c27f953ea7677a3b470eede89b058a4",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "df2 = df.sort_values(['Nationality','Overall'],ascending=False).groupby('Nationality').head(50)",
      "execution_count": 65,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "559daa38ac4237ec9b85b7fc316ffa42d21564ab"
      },
      "cell_type": "code",
      "source": "def str2number(amount):\n    if amount[-1] == 'M':\n        return float(amount[1:-1])*1000000\n    elif amount[-1] == 'K':\n        return float(amount[1:-1])*1000\n    else:\n        return float(amount[1:])\n    \ndf2['MaxPotential'] = df2['Potential'] - df2['Overall']\ndf2['ValueNum'] = df2['Value'].apply(lambda x: str2number(x))\ntop_teams = df2.groupby(\"Nationality\").sum().sort_values(\"ValueNum\", ascending=False).head(16).reset_index()[[\"Nationality\", \"Overall\", \"ValueNum\",'MaxPotential']]",
      "execution_count": 66,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "4fe64b577adacfca4351698a86651a65ed9a68a0"
      },
      "cell_type": "markdown",
      "source": "**Visualizing top 16 countries with the highest talent score**"
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "770c83cb5c2c11c085828fba993237a8a573e49e",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "trace1 = go.Bar(\n    x = top_teams[\"Nationality\"].tolist(),\n    y = top_teams[\"Overall\"].tolist(),\n    name='Country Overall',\n    marker=dict(\n        color='rgba(55, 128, 191, 0.7)',\n        line=dict(\n            color='rgba(55, 128, 191, 1.0)',\n            width=2,\n        )\n    )\n)\n\ntrace2 = go.Bar(\n    x = top_teams[\"Nationality\"].tolist(),\n    y = top_teams[\"MaxPotential\"].tolist(),\n    name='Country Potential',\n    marker=dict(\n        color='rgba(219, 64, 82, 0.7)',\n        line=dict(\n            color='rgba(219, 64, 82, 1.0)',\n            width=2,\n        )\n    )\n)\n\ntrace3 = go.Scatter(\n    x = top_teams[\"Nationality\"].tolist(),\n    y = (top_teams[\"ValueNum\"] / 1000000).tolist(),\n    name='Country Value [Mâ¬]',\n    mode = 'lines+markers',\n    yaxis='y2'\n)\n\ndata = [trace1, trace2,trace3]\n\nlayout = go.Layout(\n    barmode='stack',\n    title = 'Level of talent across countries',\n    titlefont=dict(size=25),\n    width=850,\n    height=500,\n    paper_bgcolor='rgb(244, 238, 225)',\n    plot_bgcolor='rgb(244, 238, 225)',\n    yaxis = dict(\n        title= 'Country Overall/Potential',\n        anchor = 'x',\n        rangemode='tozero'\n    ),\n    xaxis = dict(title= 'Country Name'),\n    yaxis2=dict(\n        title='Country Value [Mâ¬]',\n        titlefont=dict(\n            color='rgb(148, 103, 189)'\n        ),\n        tickfont=dict(\n            color='rgb(148, 103, 189)'\n        ),\n        overlaying='y',\n        side='right',\n        anchor = 'x',\n        rangemode = 'tozero',\n        dtick = 200\n    ),\n    #legend=dict(x=-.1, y=1.2)\n    legend=dict(x=0.05, y=0.05)\n)\n\nfig = go.Figure(data=data, layout=layout)\npy.iplot(fig)",
      "execution_count": 68,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "9363be66d16fe816a1d3df06fd03dceeb142caa3",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "# Countries identified by logreg to make it past group stages.\nnext_round_wc = world_cup.groupby('Group').nth([0, 1]) \nnext_round_wc['Team']",
      "execution_count": 79,
      "outputs": []
    },
    {
      "metadata": {
        "trusted": true,
        "_uuid": "3d395449dfe2d4125afe781aac89958da5c61a81",
        "collapsed": true
      },
      "cell_type": "code",
      "source": "# Overlaps\nnext_round_wc['Team'].isin(top_teams['Nationality']).agg('sum')",
      "execution_count": 78,
      "outputs": []
    },
    {
      "metadata": {
        "_uuid": "9669ed744cf073412a51ed59f92114347f441d13"
      },
      "cell_type": "markdown",
      "source": "***Takeaways:***\n\nOverlaying the output with the matchup predictions, we have 3 key observations:\n1.  The logistic regression model coupled with the talent visualization shows that of the 16 top overall talent countries,   11/16 of countries will make it through to the single elimination rounds. \n> While this is inconclusive, it does give an indication that the talent pool available is probably an important factor to a country's perfomance at FIFA. \n> The format of FIFA ensures that not all 16 of the top talent pool countries will make it through to the elimination stages with ease, there are multiple points of upset even before FIFA begins. For example, Italy was previously ousted due to losing to Sweden in the 2nd round playoff in Nov 2017, despite having one of the best talents.\n2. There are multiple matches with almost 50/50 chance for either side to win, this implies that the model is unable to predict with high confidence of some matchups and will need to be tweaked as the results unfold. **(this is what makes it interesting to watch isn't it)**,\n> In the quarterfinals matchup, Argentina vs Portugal, only 1 team will make it to the finals with the top 2 players by overall ratings (Ronaldo & Messi) leading on each side. Interestingly, the winning chances of Portugal is only by 0.01.\n3. In the Finals matchup between Belgium and Germany, there is a substantially higher overall talent score for Germany (4129) as compared to Belgium(3960), even if Belgium were to maximize it's potential, it will only hit a score of 4085 (which is still below Germany's overall score). Hence, unless there is significant environmental influence, both the predictive model & talent assessment results indicate Germany as the champions of FIFA 2018."
    },
    {
      "metadata": {
        "trusted": true,
        "collapsed": true,
        "_uuid": "433f5c6ea2e2b8c7775a8556c47820d5b1fe15d9"
      },
      "cell_type": "code",
      "source": "",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "name": "python",
      "version": "3.6.5",
      "mimetype": "text/x-python",
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "pygments_lexer": "ipython3",
      "nbconvert_exporter": "python",
      "file_extension": ".py"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 1
}